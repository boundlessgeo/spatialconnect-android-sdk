package com.boundlessgeo.spatialconnect.db;

import android.database.Cursor;
import android.database.DatabaseUtils;
import android.util.Log;

import com.boundlessgeo.spatialconnect.geometries.SCGeometry;
import com.boundlessgeo.spatialconnect.geometries.SCSpatialFeature;
import com.boundlessgeo.spatialconnect.query.SCQueryFilter;
import com.squareup.sqlbrite.BriteDatabase;
import com.squareup.sqlbrite.SqlBrite;
import com.vividsolutions.jts.geom.GeometryFactory;
import com.vividsolutions.jts.geom.PrecisionModel;
import com.vividsolutions.jts.io.ParseException;
import com.vividsolutions.jts.io.WKBReader;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import rx.Observable;
import rx.Subscriber;
import rx.functions.Action1;
import rx.functions.Func1;

import static com.boundlessgeo.spatialconnect.db.GeoPackage.RECEIVED_AUDIT_COL;
import static com.boundlessgeo.spatialconnect.db.GeoPackage.SENT_AUDIT_COL;

/**
 * This class is responsible for reading and writing {@link SCSpatialFeature}s to a feature table in a GeoPackage.
 */
public class SCGpkgFeatureSource {

    /**
     * The log tag for this class.
     */
    private final String LOG_TAG = SCGpkgFeatureSource.class.getSimpleName();

    /**
     * The instance of the GeoPackage used to connect to the database.
     */
    private GeoPackage gpkg;

    /**
     * The name of the table.
     */
    private String tableName;

    private String auditName;

    /**
     * The name of the primary key column.
     */
    private String primaryKeyName;

    /**
     * The name of the geometry column.
     */
    private String geomColumnName;


    /**
     * A map of the columns and their database types.
     */
    private Map<String, String> columns = new LinkedHashMap<>();
    private Map<String, String> geomertycolumns = new LinkedHashMap<>();
    private List<String> geomertyTables = new ArrayList<>();

    private BriteDatabase db;
    private static final GeometryFactory GEOMETRY_FACTORY = new GeometryFactory();

    /**
     * Creates and instance of the {@link SCGpkgFeatureSource} using the {@link GeoPackage} containing the db
     * connection and the database table name.
     *
     * @param geoPackage
     * @param tableName
     */
    public SCGpkgFeatureSource(GeoPackage geoPackage, String tableName) {
        this.gpkg = geoPackage;
        this.tableName = tableName;
        this.auditName = String.format("%s_audit", tableName);
    }

    public Map<String, String> getColumns() {
        return columns;
    }

    public void addColumn(String columnName, String columnType) {
        this.columns.put(columnName, columnType);
    }

    public void addGeometryColumn(String columnName, String columnType) {
        this.geomertycolumns.put(columnName, columnType);
    }

    public void addGeometryTables(String tableName) {
        this.geomertyTables.add(tableName);
    }

    public void setGeomColumnName(String geomColumnName) {
        this.geomColumnName = geomColumnName;
    }

    public void setPrimaryKeyName(String primaryKeyName) {
        this.primaryKeyName = primaryKeyName;
    }

    public String getTableName() {
        return tableName;
    }

    public String getPrimaryKeyName() {
        return primaryKeyName;
    }

    public String getGeomColumnName() {
        return geomColumnName;
    }

    public Map<String, String> getGeometryColumns() {
        return geomertycolumns;
    }

    public List<String> getGeometryTables() {
        return geomertyTables;
    }

    /**
     * Builds the column names part of the INSERT statement.  Only adds the columns from the feature, which may not be
     * all columns in the schema.  Note that the INSERT statement doesn't use the primary key column b/c it should be
     * auto generated by the database.
     *
     * @return a CSV string of all column names used in the INSERT statement
     */
    public String getColumnNamesForInsert(SCSpatialFeature feature) {
        StringBuilder sb = new StringBuilder();
        List<String> columnNames = new ArrayList<>(columns.keySet());
        Collections.sort(columnNames, ALPHABETICAL_ORDER);
        for (String columnName : columnNames) {
            if (feature.getProperties().get(columnName) != null) {
                sb.append(columnName + ",");
            }
        }
        sb.append(geomColumnName);
        return sb.toString();
    }

    /**
     * Builds the column values part of the INSERT statement.  In order to ensure that the columns match the values, we
     * sort the column names alphabetically.
     *
     * @return a CSV string of all column values used in the INSERT statement
     */
    public String getColumnValuesForInsert(final SCSpatialFeature feature) {
        StringBuilder sb = new StringBuilder();
        List<String> columnNames = new ArrayList<>(columns.keySet());
        Collections.sort(columnNames, ALPHABETICAL_ORDER);
        boolean firstIteration = true;
        for (String columnName : columnNames) {
            if (feature.getProperties().get(columnName) != null) {
                if (!firstIteration) {
                    sb.append(",");
                }
                sb.append(DatabaseUtils.sqlEscapeString(String.valueOf(feature.getProperties().get(columnName))));
                firstIteration = false;
            }
        }
        if (sb.toString().length() > 0) {
            sb.append(",");
        }
        if (feature instanceof SCGeometry && ((SCGeometry)feature).getGeometry() != null) {
            sb.append("ST_GeomFromText('")
                    .append(((SCGeometry)feature).getGeometry().toString())
                    .append("')");
        }
        else {
            sb.append("NULL");
        }
        return sb.toString();
    }

    /**
     * Builds the {@code SET column_name = value1, column2 = value2} part of the UPDATE statement.
     *
     * @param feature
     * @return a string containing the SET clause of the UPDATE statement
     */
    public String getUpdateSetClause(SCSpatialFeature feature) {
        StringBuilder sb = new StringBuilder();
        for (String columnName : columns.keySet()) {
            if (feature.getProperties().get(columnName) != null) {
                sb.append(columnName);
                sb.append("=");
                sb.append((DatabaseUtils.sqlEscapeString(String.valueOf(feature.getProperties().get(columnName)))));
                sb.append(", ");
            }
        }
        sb.append(geomColumnName);
        sb.append("=");
        sb.append("ST_GeomFromText('").append(((SCGeometry)feature).getGeometry().toString()).append("')");
        return sb.toString();
    }

    public SCSpatialFeature featureFromResultSet(final Cursor rs) {
        final Map<String,Object> properties = new HashMap<>();

        //check if blob and create SCGeometry
        SCSpatialFeature spatialFeature = null;
        SCGeometry geometry = null;
        // deserialize byte[] to Geometry object
        byte[] wkb = SCSqliteHelper.getBlob(rs, getGeomColumnName());
        if (wkb != null && wkb.length > 0) {
            try {
                geometry = new SCGeometry(
                        new WKBReader(new GeometryFactory(new PrecisionModel(), 0)).read(wkb));
                spatialFeature = geometry;
            } catch (ParseException e) {
                e.printStackTrace();
                Log.e(LOG_TAG, "e: " + e.getMessage());
                spatialFeature = new SCSpatialFeature();
            }
        } else {
            spatialFeature = new SCSpatialFeature();
        }

        Observable<Map.Entry<String, String>> columns =
                Observable.from(getColumns().entrySet())
                        .mergeWith(Observable.from(getGeometryColumns().entrySet()));

        columns.subscribe(new Action1<Map.Entry<String, String>>() {
            @Override
            public void call(Map.Entry<String, String> column) {
                if (column.getValue().equalsIgnoreCase("BLOB")
                        || column.getValue().equalsIgnoreCase("GEOMETRY")
                        || column.getValue().equalsIgnoreCase("POINT")
                        || column.getValue().equalsIgnoreCase("LINESTRING")
                        || column.getValue().equalsIgnoreCase("POLYGON")) {

                    SCGeometry geometry = null;
                    byte[] wkb = SCSqliteHelper.getBlob(rs, column.getKey());
                    try {
                        if (wkb != null && wkb.length > 0) {
                            geometry = new SCGeometry(
                                    new WKBReader(GEOMETRY_FACTORY).read(wkb)
                            );
                        }
                    }
                    catch (ParseException e) {
                        Log.w(LOG_TAG, "Could not parse geometry");
                    }

                    properties.put(column.getKey(),geometry);
                }
                else if (column.getValue().startsWith("INTEGER")) {
                    properties.put(
                            column.getKey(),
                            SCSqliteHelper.getInt(rs, column.getKey())
                    );
                }
                else if (column.getValue().startsWith("REAL")) {
                    properties.put(
                            column.getKey(),
                            SCSqliteHelper.getLong(rs, column.getKey())
                    );
                }
                else if (column.getValue().startsWith("TEXT")) {
                    properties.put(
                            column.getKey(),
                            SCSqliteHelper.getString(rs, column.getKey())
                    );
                }
                else {
                    Log.w(LOG_TAG, "The column type " + column.getValue() + " did not match any supported" +
                            " column type so it wasn't added to the feature.");
                }
            }
        });

        spatialFeature.setId(String.valueOf(SCSqliteHelper.getInt(rs, primaryKeyName)));
        spatialFeature.setLayerId(tableName);

        properties.remove(RECEIVED_AUDIT_COL);
        properties.remove(SENT_AUDIT_COL);
        spatialFeature.setProperties(properties);

        return spatialFeature;
    }

    public Observable<SCSpatialFeature> unSent() {

        String query;
        Map<String, String> geometrycolumns = getGeometryColumns();
        Map<String, String> nonGeometrycolumns = getColumns();
        List<String> geomTables = getGeometryTables();

        if (geometrycolumns.size() > 0) {
            StringBuilder sql = new StringBuilder();
            sql.append("SELECT ");
            boolean firstIteration = true;
            if (nonGeometrycolumns.size() > 0) {
                for (Map.Entry<String, String> nonGeom : nonGeometrycolumns.entrySet()) {
                    if (firstIteration) {
                        sql.append(nonGeom.getKey());
                        firstIteration = false;
                    } else {
                        sql.append(",");
                        sql.append(nonGeom.getKey());
                    }
                }
            }

            //add id
            sql.append(",");
            sql.append(getPrimaryKeyName());

            //add default form submission geometry
            sql.append(",");
            sql.append("ST_AsBinary(").append(getGeomColumnName()).append(") AS ").append(getGeomColumnName());

            //add other gemetry columsn
            if (geometrycolumns.size() > 0) {

                for (Map.Entry<String, String> geom : geometrycolumns.entrySet()) {
                    if (firstIteration) {
                        sql.append("ST_AsBinary(").append(geom.getKey()).append(") AS ").append(geom.getKey());
                        firstIteration = false;
                    } else {
                        sql.append(",");
                        sql.append("ST_AsBinary(").append(geom.getKey()).append(") AS ").append(geom.getKey());
                    }
                }

            }

            sql.append(" FROM ");
            sql.append(auditName);

            for (String gt : geomTables) {
                sql.append(" LEFT JOIN ");
                sql.append(String.format("%s_audit", gt));
                sql.append(" ON ");
                sql.append(String.format("%s.id", auditName));
                sql.append(" = ");
                sql.append(String.format("%s.%s_id", String.format("%s_audit", gt), tableName));
            }
            sql.append(String.format(" WHERE %s.sent IS NULL",
                    auditName));
            query = sql.toString();
        } else {
            query = String.format("SELECT %s FROM %s WHERE sent IS NULL",
                    gpkg.getSelectColumnsString(this),
                    auditName);
        }

        final String sql = query.toString();
        return Observable.create(new Observable.OnSubscribe<SCSpatialFeature>() {
            @Override
            public void call(final Subscriber subscriber) {
                query(sql, subscriber);
            }
        });
    }

    public void updateAuditTable(SCSpatialFeature feature) {
        Cursor cursor = null;
        try {
            String query =
                    String.format(Locale.US, "UPDATE %s SET sent = datetime() WHERE %s = %s",
                            this.auditName, this.primaryKeyName, feature.getId());
            cursor = gpkg.query(query);
            cursor.moveToFirst();
        } catch (Exception ex) {
            Log.e(LOG_TAG, "Something went wrong updating audit table: " + ex.getMessage());
        }
        finally {
            if (cursor != null) {
                cursor.close();
            }
        }
    }

    public void updateAuditTableFromLatest(SCSpatialFeature feature) {
        Cursor cursor = null;
        try {
            String query =
                    String.format(Locale.US, "UPDATE %s SET sent = datetime() WHERE %s <= %s AND SENT IS NULL",
                            this.auditName, this.primaryKeyName, feature.getId());
            cursor = gpkg.query(query);
            cursor.moveToFirst();
        } catch (Exception ex) {
            Log.e(LOG_TAG, "Something went wrong updating audit table: " + ex.getMessage());
        }
        finally {
            if (cursor != null) {
                cursor.close();
            }
        }
    }

    public Observable<SCSpatialFeature> query(final SCQueryFilter queryFilter) {

        final List<String> featureTableNames = queryFilter.getLayerIds().size() > 0 ?
                queryFilter.getLayerIds() :
                new ArrayList<>(gpkg.getFeatureSources().keySet());
        // TODO: decide on what to do if queryLimit division is 0
        final int queryLimit = queryFilter.getLimit() / featureTableNames.size();

        String query;
        Map<String, String> geometrycolumns = getGeometryColumns();
        Map<String, String> nonGeometrycolumns = getColumns();
        List<String> geomTables = getGeometryTables();

        if (geometrycolumns.size() > 0) {
            StringBuilder sql = new StringBuilder();
            sql.append("SELECT ");
            boolean firstIteration = true;
            if (nonGeometrycolumns.size() > 0) {
                for (Map.Entry<String, String> nonGeom : nonGeometrycolumns.entrySet()) {
                    if (firstIteration) {
                        sql.append(nonGeom.getKey());
                        firstIteration = false;
                    } else {
                        sql.append(",");
                        sql.append(nonGeom.getKey());
                    }
                }
            }

            //add id
            sql.append(",");
            sql.append(getPrimaryKeyName());

            //add default form submission geometry
            sql.append(",");
            sql.append(getGeomColumnName());

            //add other gemetry columsn
            if (geometrycolumns.size() > 0) {

                for (Map.Entry<String, String> geom : geometrycolumns.entrySet()) {
                    if (firstIteration) {
                        sql.append("ST_AsBinary(").append(geom.getKey()).append(") AS ").append(geom.getKey());
                        firstIteration = false;
                    } else {
                        sql.append(",");
                        sql.append("ST_AsBinary(").append(geom.getKey()).append(") AS ").append(geom.getKey());
                    }
                }

            }

            sql.append(" FROM ");
            sql.append(tableName);

            for (String gt : geomTables) {
                sql.append(" LEFT JOIN ");
                sql.append(gt);
                sql.append(" ON ");
                sql.append(String.format("%s.id", tableName));
                sql.append(" = ");
                sql.append(String.format("%s.%s_id", gt, tableName));
            }
            sql.append(String.format(Locale.US, " WHERE %s.%s IN (%s) LIMIT %d",
                    tableName,
                    getPrimaryKeyName(),
                    gpkg.createRtreeSubQuery(this, queryFilter.getPredicate().getBoundingBox()),
                    queryLimit));

            query = sql.toString();

        } else {
            query = String.format(Locale.US,
                    "SELECT %s FROM %s WHERE %s IN (%s) LIMIT %d",
                    getSelectColumnsString(),
                    tableName,
                    getPrimaryKeyName(),
                    gpkg.createRtreeSubQuery(this, queryFilter.getPredicate().getBoundingBox()),
                    queryLimit
            );
        }

        return gpkg.createQuery(
                tableName,
                query
        ).flatMap(getFeatureMapper(this)).onBackpressureBuffer(queryFilter.getLimit());
    }

    public Observable<SCSpatialFeature> findById(String featureId) {
        String query;
        Map<String, String> geometrycolumns = getGeometryColumns();
        Map<String, String> nonGeometrycolumns = getColumns();
        List<String> geomTables = getGeometryTables();

        if (geometrycolumns.size() > 0) {
            StringBuilder sql = new StringBuilder();
            sql.append("SELECT ");
            boolean firstIteration = true;
            if (nonGeometrycolumns.size() > 0) {
                for (Map.Entry<String, String> nonGeom : nonGeometrycolumns.entrySet()) {
                    if (firstIteration) {
                        sql.append(nonGeom.getKey());
                        firstIteration = false;
                    } else {
                        sql.append(",");
                        sql.append(nonGeom.getKey());
                    }
                }
            }

            //add id
            sql.append(",");
            sql.append(getPrimaryKeyName());

            //add default form submission geometry
            sql.append(",");
            sql.append(getGeomColumnName());

            //add other gemetry columsn
            if (geometrycolumns.size() > 0) {

                for (Map.Entry<String, String> geom : geometrycolumns.entrySet()) {
                    if (firstIteration) {
                        sql.append("ST_AsBinary(").append(geom.getKey()).append(") AS ").append(geom.getKey());
                        firstIteration = false;
                    } else {
                        sql.append(",");
                        sql.append("ST_AsBinary(").append(geom.getKey()).append(") AS ").append(geom.getKey());
                    }
                }

            }

            sql.append(" FROM ");
            sql.append(tableName);

            for (String gt : geomTables) {
                sql.append(" LEFT JOIN ");
                sql.append(gt);
                sql.append(" ON ");
                sql.append(String.format("%s.id", tableName));
                sql.append(" = ");
                sql.append(String.format("%s.%s_id", gt, tableName));
            }
            sql.append(String.format(" WHERE %s.%s = %s LIMIT 1",
                    tableName,
                    getPrimaryKeyName(),
                    featureId)) ;
            query = sql.toString();
        } else {
            query = String.format(
                    "SELECT %s FROM %s WHERE %s = %s LIMIT 1",
                    getSelectColumnsString(),
                    tableName,
                    getPrimaryKeyName(),
                    featureId
            );
        }
        return gpkg.createQuery(
                tableName,
                query
        ).flatMap(getFeatureMapper(this));
    }

    private String getSelectColumnsString() {
        StringBuilder sb = new StringBuilder();
        for (String columnName : getColumns().keySet()) {
            sb.append(columnName).append(",");
        }
        sb.append(getPrimaryKeyName()).append(",");
        String geomColumnName = getGeomColumnName();
        sb.append("ST_AsBinary(").append(geomColumnName).append(") AS ").append(geomColumnName);
        return sb.toString();
    }

    private void query(String sql, Subscriber subscriber) {
        Cursor layerCursor = gpkg.query(sql);
        try {
            while (layerCursor.moveToNext()) {
                SCSpatialFeature f = featureFromResultSet(layerCursor);
                subscriber.onNext(f);
            }
            subscriber.onCompleted();
        } catch (Exception e) {
            Log.e(LOG_TAG, "Something went wrong trying to get unsynced features: " + e.getMessage());
            subscriber.onError(e);
        } finally {
            layerCursor.close();
        }
    }

    private static Comparator<String> ALPHABETICAL_ORDER = new Comparator<String>() {
        public int compare(String str1, String str2) {
            int res = String.CASE_INSENSITIVE_ORDER.compare(str1, str2);
            if (res == 0) {
                res = str1.compareTo(str2);
            }
            return res;
        }
    };

    private Func1<SqlBrite.Query, Observable<SCSpatialFeature>> getFeatureMapper(final SCGpkgFeatureSource source) {
        return new Func1<SqlBrite.Query, Observable<SCSpatialFeature>>() {

            @Override
            public Observable<SCSpatialFeature> call(SqlBrite.Query query) {
                return query.asRows(new Func1<Cursor, SCSpatialFeature>() {
                    @Override
                    public SCSpatialFeature call(final Cursor cursor) {
                        SCSpatialFeature feature = new SCSpatialFeature();
                        // deserialize byte[] to Geometry object
                        byte[] wkb = SCSqliteHelper.getBlob(cursor, source.getGeomColumnName());
                        try {
                            if (wkb != null && wkb.length > 0) {
                                feature = new SCGeometry(
                                        new WKBReader(GEOMETRY_FACTORY).read(wkb)
                                );
                            }
                        }
                        catch (ParseException e) {
                            Log.w(LOG_TAG, "Could not parse geometry");
                        }

                        final SCSpatialFeature finalFeature = feature;
//                        finalFeature.setStoreId(scStoreConfig.getUniqueID());
                        finalFeature.setLayerId(source.getTableName());
                        finalFeature.setId(SCSqliteHelper.getString(cursor, source.getPrimaryKeyName()));

                        Observable<Map.Entry<String, String>> columns =
                                Observable.from(source.getColumns().entrySet())
                                        .mergeWith(Observable.from(source.getGeometryColumns().entrySet()));

                        columns.subscribe(new Action1<Map.Entry<String, String>>() {
                            @Override
                            public void call(Map.Entry<String, String> column) {
                                if (column.getValue().equalsIgnoreCase("BLOB")
                                        || column.getValue().equalsIgnoreCase("GEOMETRY")
                                        || column.getValue().equalsIgnoreCase("POINT")
                                        || column.getValue().equalsIgnoreCase("LINESTRING")
                                        || column.getValue().equalsIgnoreCase("POLYGON")) {

                                    SCGeometry geometry = null;
                                    byte[] wkb = SCSqliteHelper.getBlob(cursor, column.getKey());
                                    try {
                                        if (wkb != null && wkb.length > 0) {
                                            geometry = new SCGeometry(
                                                    new WKBReader(GEOMETRY_FACTORY).read(wkb)
                                            );
                                        }
                                    }
                                    catch (ParseException e) {
                                        Log.w(LOG_TAG, "Could not parse geometry");
                                    }

                                    finalFeature.getProperties().put(
                                            column.getKey(),geometry
                                    );
                                }
                                else if (column.getValue().startsWith("INTEGER")) {
                                    finalFeature.getProperties().put(
                                            column.getKey(),
                                            SCSqliteHelper.getInt(cursor, column.getKey())
                                    );
                                }
                                else if (column.getValue().startsWith("REAL")) {
                                    finalFeature.getProperties().put(
                                            column.getKey(),
                                            SCSqliteHelper.getLong(cursor, column.getKey())
                                    );
                                }
                                else if (column.getValue().startsWith("TEXT")) {
                                    finalFeature.getProperties().put(
                                            column.getKey(),
                                            SCSqliteHelper.getString(cursor, column.getKey())
                                    );
                                }
                                else {
                                    Log.w(LOG_TAG, "The column type " + column.getValue() + " did not match any supported" +
                                            " column type so it wasn't added to the feature.");
                                }
                            }
                        });

                        return finalFeature;
                    }
                });
            }
        };
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        SCGpkgFeatureSource that = (SCGpkgFeatureSource) o;

        if (!gpkg.equals(that.gpkg)) return false;
        return tableName.equals(that.tableName);

    }

    @Override
    public int hashCode() {
        int result = gpkg.hashCode();
        result = 31 * result + tableName.hashCode();
        return result;
    }
}
